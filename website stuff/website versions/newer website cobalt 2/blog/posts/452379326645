{"name":"I guess I forgot what OOP was","id":"452379326645","author":"Jack Anderson","date":"2022-08-03T12:47:00.000Z","tags":["495073320597"],"description":"The latest in the rollercoaster that is keeb: forgetting to organize the codebase at all.","body":"<h3>we've got prefaces now</h3>\n<p>\n    I guess I'll just preface this by saying AI is not sentient. It never will be. \n    That said, that doesn't mean AI can't have a sense of humour.\n    But that's not even what it is. GitHub Copilot is a technical feat (really), but it also takes code from across the internet, which I assume checks comments as well, or maybe it's trained with some other language datasets.\n    I'm getting too far off topic now, my point is, the tagline \"I forgot to remember\" was suggested by GitHub Copilot. Take that how you will. I think it's funny.\n    I'm usually pun-filled myself, but this time the title wasn't my idea, it was my friend's.\n</p>\n<p>\n    <h3>entr√©e</h3>\n</p>\n<p>\n    It's like we're at a 4 Michelin star restaurant; where's the main course?\n    <br>\n    <br>\n<p>\n    This is no 4 star restaurant.\n    <br>\n    <br>\n</p>\n<p>\n    Keeb, which is on its way to becoming my biggest and most advanced project yet, while being written in a low-level language that I'm still learning, it's a mess. \n    I'd love to say that after writing some code, compiling it, the program will work and I can get onto the next feature, but that's not how it works, which makes logical sense, but that still doesn't mean it can't be frustrating.\n    Now I'll start by accepting the generally obvious: many (not all) of these issues I'm having are because I'm using Rust. I could have done this in Node.js in likely a fraction of a time. But would that have been fun? Educational? \n    <br>\n    <br>\n</p>\n<p>\n    Given the option between easy, lazy, and low-performing, and difficult, concious and efficient, it's obvious which one I would choose. The easy one. Article's over. Goodbye.\n    <br>\n    <br>\n</p>\n<p>\n    Disclaimer: it's not, and that's not true.\n    <br>\n    <br>\n</p>\n<p>\n    Because the fact of the matter is that keeb <strong>is</strong> written in Rust. \n    When I originally wrote keeb, a lot of the code was written literally just to get it working. I knew my goal, and it was to have a customizable, easily expandable per-device codebase structure, like that of QMK already.\n    Manufacturers, creators and enthusiasts alike would be able to contribute to all areas of keeb; core, firmware, compatibility and custom functionality.\n    <br>\n    <br>\n</p>\n<p>\n    With all the functional versions of keeb created, none of them had that level of modularity.\n    The closest I'd gotten was adding a library for the Gmmk Pro, containing Led Mappings, a default keymap, and related helpers. This was a step in the right direction, but everything using these library resources was hard coded in keeb's core.\n    After writing the layer functionality, it started to become obvious that this core functionality would need to be rewritten, which would be a pain, plus it was getting hard to follow.\n    Then I had a conversation, which sparked the topic that none of my code was Object Oriented. To which I said, I haven't reached that part of the book yet.\n    <br>\n    <br>\n</p>\n<p>\n    Well, to be fair, not everything I've done in keeb was included in chapters 1-10, including closures, advanced generics, etc. So I went to read chapter 17 of the Rust book, Object Orieted Aspects of Rust.\n    That sure did help. Today, at around 5:00pm, I started a refactor of keeb, to make it Object Oriented, which in turn, without a doubt, would help me write code that was easier to understand, and way more organized.\n    <br>\n    <br>\n</p>\n<p>\n    I got as far as 8:30, and after fixing all the error messages, all but one remained: I cannot apply an external trait to an external struct. At the time of writing the code, I didn't even think about the fact that you cannot import impl blocks.\n    <br>\n    <br>\n</p>\n<p>\n    This came from a long time of determining which structure to use, and which would work. After testing out a more realistic one, I was limited by how Rust's generics work. The planned structure was a Keyboard struct, containing hardware specific information, and triggers. Then a Manager struct allows an end user (developer) to only instansiate a new Keyboard, and get right to coding custom functionality on keypress.\n    <br>\n    <br>\n</p>\n<p>\n    The main issue here is that I want to eliminate as much boilerplate code as I can, as well as keeping everything to follow a pattern. The issue is, in order to use a struct that implements a trait, both traits must implement the same functions, otherwise there would be an erorr, and those don't exist in Rust.\n    <br>\n    <br>\n</p>\n<p>\n    At this point, I've been writing this blog post long enough to forget all the little details, all I know is that I must come up with a better way of sharing structs betwen keyboards that could implement different methods, while making each step of the way have as little boilerplate as possible.\n    <br>\n    <br>\n</p>\n<p>\n    If you're interested in the minute details, you can check out the keeb github repository at the bottom of this page. Note that the refactor I'm mentioning is on a different branch, oop-refactor. Expect another branch in the coming days/weeks, whenever my mind is refreshed enough.\n    <br>\n    <br>\n</p>\n<p>\n    Something my mind is already refreshed about: our sponsor. \n    <br>\n    <br>\n</p>\n<p>\n    I'm just kidding.\n</p>\n<br>\n<a href=\"https://github.com/windingtheropes/keeb\">keeb on github. visit at your own risk ;)</a>","published":true}